# 透视HTTP协议

## HTTP/2

HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容 HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：

二进制协议，不再是纯文本；
* 可发起多个请求，废弃了 1.1 里的管道；
* 使用专用算法压缩头部，减少数据传输量；
* 允许服务器主动向客户端推送数据；
* 增强了安全性，“事实上”要求加密通信。

## HTTP/3

看到这里，你可能会问了：“HTTP/2 这么好，是不是就已经完美了呢？”

答案是否定的，这一次还是 Google，而且它要“革自己的命”。

在 HTTP/2 还处于草案之时，Google 又发明了一个新的协议，叫做 QUIC，而且还是相同的“套路”，继续在 Chrome 和自家服务器里试验着“玩”，依托它的庞大用户量和数据量，持续地推动 QUIC 协议成为互联网上的“既成事实”。

“功夫不负有心人”，当然也是因为 QUIC 确实自身素质过硬。

在去年，也就是 2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。

## HTTP是什么？HTTP又不是什么？

HTTP 就是超文本传输协议，也就是HyperText Transfer Protocol


你是怎么理解 HTTP 字面上的“超文本”和“传输协议”的？
能否谈一下你对 HTTP 的认识？越多越好。
HTTP 有什么特点？有什么优点和缺点？
HTTP 下层都有哪些协议？是如何工作的？

HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。

HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。

### HTTP 不是互联网。

互联网（Internet）是遍布于全球的许多网络互相连接而形成的一个巨大的国际网络，在它上面存放着各式各样的资源，也对应着各式各样的协议，例如超文本资源使用 HTTP，普通文件使用 FTP，电子邮件使用 SMTP 和 POP3 等。

但毫无疑问，HTTP 是构建互联网的一块重要拼图，而且是占比最大的那一块。

### HTTP 不是一个孤立的协议。

HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。

### 小结

* HTTP 是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。
* HTTP 专门用来在两点之间传输数据，不能用于广播、寻址或路由。
* HTTP 传输的是文字、图片、音频、视频等超文本数据。
* HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同时许多技术也都依赖于它。

* 互联网上绝大部分资源都使用 HTTP 协议传输；
* 浏览器是 HTTP 协议里的请求方，即 User Agent；
* 服务器是 HTTP 协议里的应答方，常用的有 Apache 和 Nginx；
* CDN 位于浏览器和服务器之间，主要起到缓存加速的作用；
* 爬虫是另一类 User Agent，是自动访问网络资源的程序。

URI 主要有三个基本的部分构成：

1.协议名：即访问该资源应当使用的协议，在这里是“http”；
2.主机名：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”；
3.路径：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。

HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”

SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。

SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。

* TCP/IP 是网络世界最常用的协议，HTTP 通常运行在 TCP/IP 提供的可靠传输基础上；
* DNS 域名是 IP 地址的等价替代，需要用域名解析实现到 IP 地址的映射；
* URI 是用来标记互联网上资源的一个名字，由“协议名 + 主机名 + 路径”构成，俗称 URL；
* HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”，为 HTTP 套了一个安全的外壳；
* 代理是 HTTP 传输过程中的“中转站”，可以实现缓存加速、负载均衡等功能。


## 常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？

## 四层

* 第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。

* 第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。

* 第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。
  * TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。

* 协议栈的第四层叫“应用层”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。

MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。

### OSI 网络分层模型

OSI，全称是“开放式系统互联通信参考模型”（Open System Interconnection Reference Model）。

* 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；
* 第二层：数据链路层，它基本相当于 TCP/IP 的链接层；
* 第三层：网络层，相当于 TCP/IP 里的网际层；
* 第四层：传输层，相当于 TCP/IP 里的传输层；
* 第五层：会话层，维护网络中的连接状态，即保持会话和同步；
* 第六层：表示层，把数据转换为合适、可理解的语法和语义；
* 第七层：应用层，面向具体的应用传输数据。

四层”“七层”这样的说法就逐渐流行开了。不过在实际工作中你一定要注意，这种说法只是“理论上”的层次，并不是与现实完全对应。

### 两个分层模型的映射关系

第一层：物理层，TCP/IP 里无对应；
第二层：数据链路层，对应 TCP/IP 的链接层；
第三层：网络层，对应 TCP/IP 的网际层；
第四层：传输层，对应 TCP/IP 的传输层；
第五、六、七层：统一对应到 TCP/IP 的应用层。

所谓的“四层负载均衡”就是指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。

所谓的“七层负载均衡”就是指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。



你可以把 HTTP 利用 TCP/IP 协议栈传输数据想象成一个发快递的过程。

假设你想把一件毛绒玩具送给朋友，但你要先拿个塑料袋套一下，这件玩具就相当于 HTTP 协议里要传输的内容，比如 HTML，然后 HTTP 协议为它加一个 HTTP 专用附加数据。

你把玩具交给快递小哥，为了保护货物，他又加了层包装再贴了个标签，相当于在 TCP 层给数据再次打包，加上了 TCP 头。

接着快递小哥下楼，把包裹放进了三轮车里，运到集散点，然后再装进更大的卡车里，相当于在 IP 层、MAC 层对 TCP 数据包加上了 IP 头、MAC 头。

之后经过漫长的运输，包裹到达目的地，要卸货再放进另一位快递员的三轮车，就是在 IP 层、MAC 层传输后拆包。

快递员到了你朋友的家门口，撕掉标签，去除了 TCP 层的头，你朋友再拆掉塑料袋包装，也就是 HTTP 头，最后就拿到了玩具，也就是真正的 HTML 页面。

二层转发：设备工作在链接层，获取了数据报的头部信息之后，根据目标的MAC地址，进行本地转发和广播
三层路由：设备工作在IP层，通过分析数据报的头部信息，得到IP地址，根据网段范围，进行本地转发或选择下一个网关
dns和cdn都在应用层


## 域名里有哪些门道？

目前全世界有几亿个站点，有几十亿网民，而每天网络上发生的 HTTP 流量更是天文数字。这些请求绝大多数都是基于域名来访问网站的，所以 DNS 就成了互联网的重要基础设施，必须要保证域名解析稳定可靠、快速高效。


DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：

* 根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；
* 顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；
* 权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。

所以在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“缓存”。

首先，许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。

这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方。比较知名的 DNS 有 Google 的“8.8.8.8”，Microsoft 的“4.2.2.1”，还有 CloudFlare 的“1.1.1.1”等等。

其次，操作系统里也会对 DNS 解析结果做缓存，如果你之前访问过“www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到 DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。

另外，操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是“/etc/hosts”，在 Windows 里是“C:\WINDOWS\system32\drivers\etc\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。

使用 DNS 可以实现基于域名的负载均衡，既可以在内网，也可以在外网

浏览器缓存->操作系统缓存->hosts->dns


## 键入网址再按下回车，后面究竟发生了什么？

最简单的浏览器 HTTP 请求过程：

* 浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；
* 浏览器用 TCP 的三次握手与服务器建立连接；
* 浏览器向服务器发送拼好的报文；
* 服务器收到报文后处理请求，同样拼好报文再发给浏览器；
* 浏览器解析报文，渲染输出页面。

访问流程

浏览器判断是不是ip地址，不是就进行域名解析，依次通过浏览器缓存，系统缓存，host文件，还是没找到的请求DNS服务器获取IP解析(解析失败的浏览器尝试换别的DNS服务器，最终失败的进入错误页面)，有可能获取到CDN服务器IP地址，访问CDN时先看是否缓存了，缓存了响应用户，无法缓存，缓存失效或者无缓存，回源到服务器。经过防火墙外网网管路由到nginx接入层。nginx缓存中存在的直接返回回，不存在的负载到web服务器


## HTTP报文是什么样子的？

### HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：

* 起始行（start line）：描述请求或响应的基本信息；
* 头部字段集合（header）：使用 key-value 形式更详细地说明报文；
* 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

### 请求行(起始行)由三部分构成：

* 请求方法：是一个动词，如 GET/POST，表示对资源的操作；
* 请求目标：通常是一个 URI，标记了请求方法要操作的资源；
* 版本号：表示报文使用的 HTTP 协议版本。

### 状态行

* 版本号：表示报文使用的 HTTP 协议版本；
* 状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；
* 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。

## 应该如何理解请求方法？

### 目前 HTTP/1.1 规定了八种方法

* GET：获取资源，可以理解为读取或者下载数据；
* HEAD：获取资源的元信息；
* POST：向资源提交数据，相当于写入或上传数据；
* PUT：类似 POST(通常 POST 表示的是“新建”“create”的含义，而 PUT 则是“修改”“update”的含义)；
* DELETE：删除资源；
* CONNECT：建立特殊的连接隧道；
* OPTIONS：列出可对资源实行的方法；
* TRACE：追踪请求 - 响应的传输路径。

### 安全与幂等

按照这个定义，只有 GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。

而 POST/PUT/DELETE 操作会修改服务器上的资源，增加或删除数据，所以是“不安全”的。

所谓的“幂等”实际上是一个数学用语，被借用到了 HTTP 协议里，意思是多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”。

很显然，GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。

POST 和 PUT 的幂等性质就略费解一点。

按照 RFC 里的语义，POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。

我对你的建议是，你可以对比一下 SQL 来加深理解：把 POST 理解成 INSERT，把 PUT 理解成 UPDATE，这样就很清楚了。多次 INSERT 会添加多条记录，而多次 UPDATE 只操作一条记录，而且效果相同。

## 你能写出正确的网址吗？

* URI 是用来唯一标记服务器上资源的一个字符串，通常也称为 URL；
* URI 通常由 scheme、host:port、path 和 query 四个部分组成，有的可以省略；
* scheme 叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问；
* “host:port”表示资源所在的主机名和端口号；
* path 标记资源所在的位置；
* query 表示对资源附加的额外要求；
* 在 URI 里对“@&/”等特殊字符和汉字必须要做编码，否则服务器收到 HTTP 报文后会无法正确处理。

## 响应状态码该怎么用？

* 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
* 2××：成功，报文已经收到并被正确处理；
* 3××：重定向，资源位置发生变动，需要客户端重新发送请求；
* 4××：客户端错误，请求报文有误，服务器无法处理；
* 5××：服务器错误，服务器在处理请求时内部发生了错误。

“400 Bad Request”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是“一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。

“403 Forbidden”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。

“404 Not Found”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。


“500 Internal Server Error”与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。

“501 Not Implemented”表示客户端请求的功能还不支持，这个错误码比 500 要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。

“502 Bad Gateway”通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。

“503 Service Unavailable”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503。

## HTTP有哪些特点？

* HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；
* HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；
* HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；
* HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；
* HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。

1、如果要 100%保证数据收发成功就不能使用HTTP或者TCP协议了，而是要用各种消息中间件(MQ),如RabbitMQ、ZeroMQ、Kafka等。

2、以前HTTP协议还有一个“无连接”的特点，指的是协议不保持连接状态，每次请求应答后都会关闭连接，这就和UDP几乎一模一样了。但这样会很影响性能，在HTTP/1.1里就改成了总是默认启用keepalive长连接机制，所以现在的HTTP已经不再是“无连接”的了。

3、注意HTTP的“无状态”特点与响应头里的“状态码”是完全不相关的两个概念，状态码表示的是此次报文处理的结果，并不会导致服务器内部状态变化。

## HTTP有哪些优点？又有哪些缺点？

* HTTP 最大的优点是简单、灵活和易于扩展；
* HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；
* HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；
* HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；
* HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；
* HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。



