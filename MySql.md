## MySql
### 1、sql优化
1.业务拆分，相关字段冗余或者合并成临时表；
<br><br>2.分表查询，单表查询之后的结果进行字段整合；
<br><br>3.查询条件做索引（mysql数据库索引在内存里面）；
<br><br>4.数量大的表进行历史表分离（500w到1000w）；
<br><br>5.数据库主从分离，读写分离，mysql有自带的binlog实现 主从同步；
<br><br>6.explain分析sql语句，查看执行计划，分析索引是否用上，分析扫描行数等等。
### 2、PreparedStatement接口代表预编译的语句
它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）、性能高。
### 3、 SQL标准定义了4类隔离级别
用来限定事务内外的哪些改变是可见的，哪些是不可见的。
<br><br>1.Read Uncommitted（读取未提交内容）,脏读（Dirty Read）.
<br><br>2.Read Committed（读取提交内容）不可重复读（Nonrepeatable Read），
因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。
<br><br>3.Repeatable Read（可重读）,MySQL的默认事务隔离级别,
幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，
另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。
InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。
<br><br>4.Serializable（可串行化）,每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
<br><br><br>![四种隔离级别](https://github.com/gaoyuanyuan2/notes/blob/master/img/1.jpg) 
### 5、CHAR
固定长度，所以速度比VARCHAR
（长度可变，比较节省空间，所以对磁盘I/O和数据存储总量比较好）速度要快，但是它的缺点就是浪费存储空间。
### 6、EXISTS
关键字后面的参数是一个任意的子查询，判断是否返回行，如果至少返回一行，
那么EXISTS的结果为true，如果没有任何行，此时外层语句将不进行查询。
### 7、13、	数据库存储引擎
数据库底层软件组件，DBMS使用数据引擎进行创建、更新、删除数据操作。MySQL的核心就是存储引擎。包括处理安全事务安全表引擎和处理非事务安全表的引擎。MySQL5.5支持的存储引擎有：
<br><br>InnoDB：支持事务安全表（ACID）,支持行锁定和外键。
<br><br>MyISAM：较高的插入查询速度，但不支持事务。
<br><br>Memory：将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。
,Merge,Archive,Federated,CSV,BLACKHOLE等
MySQL不同版本中默认存储引擎不同，MySQL允许修改默认存储引擎，方法是修改配置文件。
### 8、索引
没有索引必须遍历整个表，索引是在存储引擎中实现的,索引的本质：索引是数据结构。[原理](https://blog.csdn.net/debug_zhang/article/details/52168552)
<br><br>LIKE 关键字匹配字符串以“%”开头，索引不会起作用。OR查询，一个字段没有使用索引，那么其他的索引也不会起作用。
<br><br>尽量使用短索引，短索引不仅可以提高查询速度而且可以节省磁盘空间、减少I/O操作。
<br><br>
  (1)索引并非越多越好，一个表中如有大量的索引,不仅占用磁盘空间，而且会影响INSERT、DEL ETE. UPDATE等语句的性能，因为当表中的数据更改的同时，索引也会进行调整和更新。
  <br><br>(2)避免对经常更新的表进行过多的索引，并且索引中的列尽可能少。而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段。
  <br><br>(3)数据量小的表最好不要使用索引，由于数据较少，查询花费的时向可能比遍历索引的时间还要短，索引可能不会产生优化效果。
  <br><br>(4)在条件表达式中经常用到的不同值较多的列上建立索引，在不同值少的列上不要建立索引。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须建立索引。如果建立索引不但不会提高查询效率，反而会严重降低更新速度。
  <br><br>(5)当唯一性是某种数据本身的特征时，指定唯一霸引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。
  <br><br>(6)在频繁进行排序或分组(即进行group by或order by操作)的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。
  
  <br><br> MySQL的索引可以分为以下几类:
  <br><br>1.普通索引和唯一索引
  <br><br>2.单列索引和组合索引
  <br>单列索引即一个索引只包含单个列，一个表可以有多个单列索引。
  组合索引指在表的多个字段组合，上创建的索引，只有在查询条件中使用了这些字段的`左边`字段时，索引才会被使用。使用组合索引时遵循最左前缀集合。
  <br><br>3.全文索引
  <br>全文索引类型为FULLTEXT,在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建。MySQL中只有MyISAM存储引擎支持全文索引。
  <br><br>4.空间索引
  <br>空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4种，分别是:GEOMETRY. POINT、LINESTRING 和POLYGON。MySQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类似的语法创建空间索引。创建空间索引的列，必须将其声明为NOTNULL，空间索引只能在存储引擎为My1SAM的表中创建。

#### 索引创建规则
<br>1.  最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)
<br><br>2.  顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
<br><br>3.  =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式
<br><br>4.  尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)
，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录
<br><br>5.  索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = 
’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);
尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可



