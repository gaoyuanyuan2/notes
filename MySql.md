# MySql
## sql优化

1.业务拆分，相关字段冗余或者合并成临时表；

2.分表查询，单表查询之后的结果进行字段整合；

3.查询条件做索引（mysql数据库索引在内存里面）；

4.数量大的表进行历史表分离（500w到1000w）；

5.数据库主从分离，读写分离，mysql有自带的binlog实现 主从同步；

6.explain分析sql语句，查看执行计划，分析索引是否用上，分析扫描行数等等。

7.大量更新不能建索引

## PreparedStatement接口代表预编译的语句

它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）、性能高。

## SQL标准定义了4类隔离级别

用来限定事务内外的哪些改变是可见的，哪些是不可见的。

1.Read Uncommitted（读取未提交内容）,脏读（Dirty Read）.

2.Read Committed（读取提交内容）不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

3.Repeatable Read（可重读）,MySQL的默认事务隔离级别,幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。

InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

4.Serializable（可串行化）,每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

![四种隔离级别](https://github.com/gaoyuanyuan2/notes/blob/master/img/1.jpg) 

## CHAR

固定长度，所以速度比VARCHAR（长度可变，比较节省空间，所以对磁盘I/O和数据存储总量比较好）速度要快，但是它的缺点就是浪费存储空间。

## EXISTS

关键字后面的参数是一个任意的子查询，判断是否返回行，如果至少返回一行，那么EXISTS的结果为true，如果没有任何行，此时外层语句将不进行查询。

###  数据库存储引擎

数据库底层软件组件，DBMS使用数据引擎进行创建、更新、删除数据操作。MySQL的核心就是存储引擎。包括处理安全事务安全表引擎和处理非事务安全表的引擎。MySQL5.5支持的存储引擎有：

InnoDB：支持事务安全表（ACID）,支持行锁定和外键。

MyISAM：较高的插入查询速度，但不支持事务。

Memory：将表中的数据存储到内存中，为查询和引用其他表数据提供快速访问。,Merge,Archive,Federated,CSV,BLACKHOLE等

MySQL不同版本中默认存储引擎不同，MySQL允许修改默认存储引擎，方法是修改配置文件。

### 8、索引

没有索引必须遍历整个表，索引是在存储引擎中实现的,索引的本质：索引是数据结构。

[原理](https://blog.csdn.net/debug_zhang/article/details/52168552)

LIKE 关键字匹配字符串以“%”开头，索引不会起作用。OR查询，一个字段没有使用索引，那么其他的索引也不会起作用。（注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引）

尽量使用短索引，短索引不仅可以提高查询速度而且可以节省磁盘空间、减少I/O操作。

如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引。

(1)索引并非越多越好，一个表中如有大量的索引,不仅占用磁盘空间，而且会影响INSERT、DEL ETE. UPDATE等语句的性能，因为当表中的数据更改的同时，索引也会进行调整和更新。

(2)避免对经常更新的表进行过多的索引，并且索引中的列尽可能少。而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段。

(3)数据量小的表最好不要使用索引，由于数据较少，查询花费的时向可能比遍历索引的时间还要短，索引可能不会产生优化效果。

(4)在条件表达式中经常用到的不同值较多的列上建立索引，在不同值少的列上不要建立索引。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须建立索引。如果建立索引不但不会提高查询效率，反而会严重降低更新速度。

(5)当唯一性是某种数据本身的特征时，指定唯一霸引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。

 (6)在频繁进行排序或分组(即进行group by或order by操作)的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。
  

MySQL的索引可以分为以下几类:

1.普通索引和唯一索引

普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值。

唯一索引，索引列的值必须唯一 ，但允许有空值。如果是组合索引，则列值的组合必须唯一。主键索引是一种特殊的唯一索引，不允许有空值。

2.单列索引和组合索引

单列索引即一个索引只包含单个列，一个表可以有多个单列索引。

组合索引指在表的多个字段组合，上创建的索引，只有在查询条件中使用了这些字段的`左边`字段时，索引才会被使用。使用组合索引时遵循最左前缀集合。

3.全文索引

用 like + % 就可以实现模糊匹配了，为什么还要全文索引？like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。

全文索引类型为FULLTEXT,在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建。

MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引。

4.空间索引

空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4种，分别是:GEOMETRY. POINT、LINESTRING 和POLYGON。MySQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类似的语法创建空间索引。创建空间索引的列，必须将其声明为NOTNULL，空间索引只能在存储引擎为My1SAM的表中创建。

5. mysql联合索引

命名规则：表名_字段名

1、需要加索引的字段，要在where条件中

2、数据量少的字段不需要加索引

3、如果where条件中是OR关系，加索引不起作用



4、符合最左原则

联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。


## 索引创建规则

1.  最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)

2.  顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

3.  =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

4.  尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，
那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录

5.  索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，
需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可

此外，查看索引的使用情况

show status like ‘Handler_read%';

注意：

handler_read_key:这个值越高越好，越高表示使用索引查询到的次数

handler_read_rnd_next:这个值越高，说明查询低效

## 锁

1. 悲观锁

 排它锁，当事务在操作数据时把这部分数据进行锁定,直到操作完毕后再解锁,其他事务操作才可操作该部分数据。这将防止其他进程读取或修改表中的数据。
 
 实现:大多数情况下依靠数据库的锁机制实现
 
一般使用 select ..for update对所选择的数据进行加锁处理,例如select * from account where name="Max" for update。这条sql 语句锁定了account表中所有符合检索条件( name="Max" )的记录。
本次事务提交之前(事务提交时会释放事务过程中的锁) ,外界无法修改这些记录。

2. 乐观锁

如果有人在你之前更新了,你的更新应当是被拒绝的,可以让用户重新操作。

 实现:大多数基于数据版本( Version )记录机制实现
 
具体可通过给表加一个版本号或时间戳字段实现,当读取数据时，将version字段的值一同读出，数据每更新次，对此version值加。
当我们提交更新的时候，判断当前版本信息与第一次取出来的版本值大小，如果数据库表当前版本号与第一次取出来的version值相等 ，则予以更新，否则认为是过期数据，拒绝更新，让用户重新操作。





