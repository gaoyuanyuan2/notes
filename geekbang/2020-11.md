# 极客学习 

* 基础课程，操作系统、计算机网络、编译原理等等，当然还有数据结构和算法。

* 通过在公司工作提高自己的技能，让自己可以更为独立和自由地生活。

* 提高代码的重用度，能自动化的就自动化，和需求人员谈需求，简化掉需求。

* 并不是社会不尊重程序员，只要你能帮上大忙，就一定会赢得别人的尊重。

## 安全

* 1.使用开源的框架必须实时关注其动态，特别是安全漏洞方面

* 2.任何公开的入口，都必须进行严格的安全检查

* 3.框架的选型十分重要，必须将安全考察进去


### 以这些公司为例，我们来看看这些攻击是怎样实现的。

1. 利用程序框架或库的已知漏洞。比如这次 Equifax 被攻击，就是通过 Apache Struts 的
已知漏洞。RSA 被攻击，也利用了 Adobe Flash 的已知漏洞。还有之前的“心脏流
血”也是使用了 OpenSSL 的漏洞……

2. 暴力破解密码。利用密码字典库或是已经泄露的密码来“撞库”。

3. 代码注入。通过程序员代码的安全性问题，如 SQL 注入、XSS 攻击、CSRF 攻击等取得
用户的权限。

4. 利用程序日志不小心泄露的信息。携程的信息泄露就是本不应该能被读取的日志没有权
限保护被读到了。

5. 社会工程学。RSA 被攻击，第一道防线是人——RSA 的员工。只有员工的安全意识增强
了，才能抵御此类攻击。其它的如钓鱼攻击也属于此类。

然后，除了表面的攻击之外，窃取到的信息也显示了一些数据管理上的问题。

1. 只有一层安全。Equifax 只是被黑客攻破了管理面板和数据库，就造成了数据泄露。显然
这样只有一层安全防护是不够的。

2. 弱密码。Equifax 数据泄露事件绝对是管理问题。至少，密码系统应该不能让用户设置如
此简单的密码，而且还要定期更换。最好的方式是通过数据证书、VPN、双因子验证的
方式来登录。

3. 向公网暴露了内部系统。在公司网络管理上出现了非常严重的问题。

4. 对系统及时打安全补丁。监控业内的安全漏洞事件，及时做出响应，这是任何一个有高
价值数据的公司都需要干的事。

5. 安全日志被暴露。安全日志往往包含大量信息，被暴露是非常危险的。携程的 CVV 泄露
就是从日志中被读到的。

6. 保存了不必要保存的用户数据。携程保存了用户的信用卡号、有效期、姓名和 CVV 码，
这些信息足以让人在网上盗刷信用卡。其实对于临时支付来说，这些信息完全可以不保
存在磁盘上，临时在内存中处理完毕立即销毁，是最安全的做法。即便是快捷支付，也
没有必要保存 CVV 码。安全日志也没有必要将所有信息都保存下来，比如可以只保存卡
号后四位，也同样可以用于处理程序故障。

7. 密码没有被合理地散列。以现代的安全观念来说，以明文方式保存密码是很不专业的做
法。进一步的是只保存密码的散列值（用安全散列算法），LinkedIn 就是这样做的。但
是，散列一则需要用目前公认安全的算法（比如 SHA-2 256），而已知被攻破的算法则
最好不要使用（如 MD5，能人为找到碰撞，对密码验证来说问题不大），二则要加一个
安全随机数作为盐（salt）。LinkedIn 的问题正在于没有加盐，导致密码可以通过预先
计算的彩虹表（rainbow table）反查出明文。这些密码明文可以用来做什么事，就不好
说了，撞库什么的都有可能了。对用户来说，最好是不同网站用不同密码。

### 5 条最佳实践。

1. 理解你的软件产品中使用了哪些支持性框架和库，它们的版本号分别是多少。时刻跟踪
影响这些产品和版本的最新安全性声明。

2. 建立一个流程，来快速地部署带有安全补丁的软件产品发布版，这样一旦需要因为安全
方面的原因而更新支持性框架或库，就可以快速地发布。最好能在几个小时或几天内完
成，而不是几周或几个月。我们发现，绝大多数被攻破的情况是因为几个月或几年都没
有更新有漏洞的软件组件而引起的。

3. 所有复杂的软件都有漏洞。不要基于“支持性软件产品没有安全性漏洞”这样的假设来
建立安全策略。

4. 建立多个安全层。在一个面向公网的表示层（比如 Apache Struts 框架）后面建立多级
有安全防护的层次，是一种良好的软件工程实践。就算表示层被攻破，也不会直接提供
出重要（或所有）后台信息资源的访问权。

5. 针对公网资源，建立对异常访问模式的监控机制。现在有很多侦测这些行为模式的开源
和商业化产品，一旦发现异常访问就能发出警报。作为一种良好的运维实践，我们建议
针对关键业务的网页服务应用一定要有这些监控机制。

### 技术上的安全做法

首先，我们需要把我们的关键数据定义出来，然后把这些关键数据隔离出来，隔离到一个安
全级别非常高的地方。所谓安全级别非常高的地方，即这个地方需要有各种如安全审计、安
全监控、安全访问的区域。

一般来说，在这个区域内，这些敏感数据只入不出。通过提供服务接口来让别的系统只能在
这个区域内操作这些数据，而不是把数据传出去，让别的系统在外部来操作这些数据。
举个例子，用户的手机号是敏感信息。如果有外部系统需要使用手机号，一般来说是想发个
短信，那么我们这个掌管手机号数据的系统就对外提供发短信的功能，而外部系统通过
UID 或是别的抽像字段来调用这个系统的发短信的 API。信用卡也一样，提供信用卡的扣
款 API 而不是把卡号返回给外部系统。

另外，如果业务必需返回用户的数据，一般来说，最终用户可能需要读取自己的数据，那
么，对于像信用卡这样的关键数据是死也不能返回全部数据的，只能返回一个被“马赛
克”了的数据（隐藏掉部分信息）。就算需要返回一些数据（如用户的地址），那么也需要
在传输层上加密返回。

而用户加密的算法一定要采用非对称加密的方式，而且还要加上密钥的自动化更换，比如：
在外部系统调用 100 次或是第一个小时后就自动更换加密的密钥。这样，整个系统在运行
时就完全是自动化的了，而就算黑客得到了密钥，密匙也会过期，这样可以控制泄露范围。
通过上述手段，我们可以把数据控制在一个比较小的区域内。

而在这个区域内，我们依然会有相关的内部员工可以访问，因此，这个区域中的数据也是需
要加密存放的，而加密使用的密钥则需要放在另外一个区域中。也就是说，被加密的数据和用于加密的密钥是由不同的人来管理的，有密钥的人没有数据，
有数据的人没有密钥，这两拨人可以有访问自己系统的权限，但是没有访问对方系统的权
限。这样可以让这两拨人互相审计，互相牵制，从而提高数据的安全性。比如，这两拨人是
不同公司的。

而密钥一定要做到随机生成，最好是对于不同用户的数据有不同的密钥，并且时不时地就能
自动化更新一下，这样就可以做到内部防范。注明一下，按道理来说，用户自己的私钥应该
由用户自己来保管，而公司的系统是不存的。而用户需要更新密钥时，需要对用户做身份鉴
别，可以通过双因子认证，也可以通过更为严格的物理身份验证。例如，到银行柜台拿身份
证重置密码。

最后，每当这些关键信息传到外部系统，需要做通知，最好是通知用户和自己的管理员。并
且限制外部系统的数据访问量，超过访问量后，需要报警或是拒绝访问。

## 何为技术领导力？

尊重技术的公司和不尊重技术的公司在初期可能还不能显现，而长期来看，差距就很明显了。

* 能够发现问题。能够发现现有方案的问题。
* 能够提供解决问题的思路和方案，并能比较这些方案的优缺点。
* 能够做出正确的技术决定。用什么样的技术、什么解决方案、怎样实现来完成一个项目。
* 能够用更优雅，更简单，更容易的方式来解决问题。
* 能够提高代码或软件的扩展性、重用性和可维护性。
* 能够用正确的方式管理团队。
  * 让正确的人做正确的事，并发挥每个人的潜力；
  * 可以提高团队的生产力和人效，找到最有价值的需求，用最少的成本实现之。并且，可以不断地提高自身和团队的标准。创新能力。
* 能够使用新的方法新的方式解决问题，追逐新的工具和技术。

##  如何才能拥有技术领导力？

* 第一，你要吃透基础技术。基础技术是各种上层技术共同的基础。

### 编程部分

* C 语言：相对于很多其他高级语言来说，C 语言更接近底层。在具备跨平台能力的前提下，它可以比较容易地被人工翻译成相应的汇编代码。它的内存管理更为直接，可以让我们直接和内存地址打交道。
* 编程范式：各种编程语言都有它们各自的编程范式，用于解决各种问题。比如面向对象编程（C++、Java）、泛型编程（C++、Go、C#）、函数式编程（JavaScript、 Python、Lisp、Haskell、Erlang）等。
* 算法和数据结构：算法（及其相应的数据结构）是程序设计的有力支撑。适当地应用算法，可以有效地抽象问题，提高程序的合理性和执行效率。算法是编程中最最重要的东西，也是计算机科学中最重要的基础。

### 系统部分

* 计算机系统原理：CPU 的体系结构（指令集 [CISC/RISC]、分支预测、缓存结构、 总线、DMA
、中断、陷阱、多任务、虚拟内存、虚拟化等），内存的原理与性能特点（SRAM、DRAM、DDR-SDRAM
 等），磁盘的原理（机械硬盘 [盘面、磁头臂、磁头、启停区、寻道等]、固态硬盘 [页映射、块的合并与回收算法、TRIM 指令等]），GPU 的原理等。
 
* 操作系统原理和基础：进程、进程管理、线程、线程调度、多核的缓存一致性、信号量、物理内存管理、虚拟内存管理、内存分配、文件系统、磁盘管理等。

* 网络基础：计算机网络是现代计算机不可或缺的一部分。需要了解基本的网络层次结构（ISO/OSI 模型、TCP/IP 协议栈），包括物理层、数据链路层（包含错误重发机制）、网络层（包含路由机制）、传输层（包含连接保持机制）、会话层、表示层、应用层（在 TCP/IP 协议栈里，这三层可以并为一层）。
 
* 数据库原理：数据库管理系统是管理数据库的利器。

* 分布式技术架构：数据库和应用程序服务器在应对互联网上数以亿计的访问量的时候，需要能进行横向扩展，这样才能提供足够高的性能。为了做到这一点，要学习分布式技术架构，包括负载均衡、DNS 解析、多子域名、无状态应用层、缓存层、数据库分片、容错和恢复机制、Paxos、Map/Reduce 操作、分布式 SQL 数据库一致性（以 Google Cloud Spanner 为代表）等知识点。

### 坚持做正确的事。做正确的事，比用正确的方式做事更重要，因为这样才始终会向目的地靠拢。哪些是正确的事呢？下面是我的观点：

* 提高效率的事。你要学习和掌握良好的时间管理方式，管理好自己的时间，能显著提高自己的效率。

* 自动化的事。程序员要充分利用自己的职业特质，当看见有可以自动化的步骤时，编写程序来自动化操作，可以显著提高效率。

* 掌握前沿技术的事。掌握前沿的技术，有利于拓展自己的眼界，也有利于找到更好的工作。需要注意的是，有些技术虽然当下很火，但未必前沿，而是因为它比较易学易用，或者性价比高。由于学习一门技术需要花费不少时间，你应该选择自己最感兴趣的，有的放矢地去学习。

* 知识密集型的事。知识密集型是相对于劳动密集型来说的。基本上，劳动密集型的事都能通过程序和机器来完成，而知识密集型的事却仍需要人来完成，所以人的价值此时就显现出来了。虽然现在人工智能似乎能做一些知识密集型的事（包括下围棋的 AlphaGo），但是在开放领域中相对于人的智能来说还是相去甚远。掌握了领域知识的人的价值依然很高。

* 技术驱动的事。不仅是指用程序驱动的事，而且还包括一切技术改变生活的事。比如自动驾驶、火星登陆等。就算自己一时用不着，你也要了解这些，以便将来这些技术来临时能适应它们。

## PaaS 层的技术主要能解决下面这些问题

* 软件生产线的问题。持续集成和持续发布，以及 DevOps 中的技术必须通过 PaaS。

* 分布式服务化的问题。分布式服务化的服务高可用、服务编排、服务调度、服务发现、服务路由，以及分布式服务化的支撑技术完全是 PaaS 的菜。

* 提高服务的可用性 SLA。提高服务可用性 SLA 所需要的分布式、高可用的技术架构和运维工具，也是 PaaS 层提供的。

* 软件能力的复用。软件工程中的核心就是软件能力的复用，这一点也完美地体现在 PaaS 平台的技术上。

Go 语言和 Docker 作为 PaaS 平台的关键技术前途是无限的

## 异常

### 你可能会觉得异常捕捉对程序的性能是有影响的，这句话也对也不对。原因是这样的。

* 异常捕捉的确是对性能有影响的，那是因为一旦异常被抛出，函数也就跟着 return 了。而程序在执行时需要处理函数栈的上下文，这会导致性能变得很慢，尤其是函数栈比较深的时候。

* 但从另一方面来说，异常的抛出基本上表明程序的错误。程序在绝大多数情况下，应该是在没有异常的情况下运行的，所以，有异常的情况应该是少数的情况，不会影响正常处理的性能问题。

### 错误返回码 vs 异常捕捉

* 对于我们并不期望会发生的事，我们可以使用异常捕捉；

* 对于我们觉得可能会发生的事，使用返回码。

### 异步编程

对此，在异步编程的世界里，我们也会有好几种处理错误的方法，最常用的就是 callback 方式。
在做异步请求的时候，注册几个 OnSuccess()、 OnFailure() 这样的函数，让在另一个线程中运行的异步代码来回调过来。

### 错误处理的最佳实践

* 统一分类的错误字典。无论你是使用错误码还是异常捕捉，都需要认真并统一地做好错误的分类。最好是在一个地方定义相关的错误。比如，HTTP 的 4XX 表示客户端有问题，5XX 则表示服务端有问题。也就是说，你要建立一个错误字典。

* 同类错误的定义最好是可以扩展的。这一点非常重要，而对于这一点，通过面向对象的继承或是像 Go 语言那样的接口多态可以很好地做到。这样可以方便地重用已有的代码。

* 定义错误的严重程度。比如，Fatal 表示重大错误，Error 表示资源或需求得不到满足，Warning 表示并不一定是个错误但还是需要引起注意，Info 表示不是错误只是一个信息，Debug 表示这是给内部开发人员用于调试程序的。

* 错误日志的输出最好使用错误码，而不是错误信息。打印错误日志的时候，应该使用统一的格式。但最好不要用错误信息，而应使用相应的错误码，错误码不一定是数字，也可以是一个能从错误字典里找到的一个唯一的可以让人读懂的关键字。这样，会非常有利于日志分析软件进行自动化监控，而不是要从错误信息中做语义分析。比如：HTTP 的日志中就会有 HTTP 的返回码，如：404。但我更推荐使用像PageNotFound这样的标识，这样人和机器都很容易处理。

* 忽略错误最好有日志。不然会给维护带来很大的麻烦。

* 对于同一个地方不停的报错，最好不要都打到日志里。不然这样会导致其它日志被淹没了，也会导致日志文件太大。最好的实践是，打出一个错误以及出现的次数。

* 不要用错误处理逻辑来处理业务逻辑。也就是说，不要使用异常捕捉这样的方式来处理业务逻辑，而是应该用条件判断。如果一个逻辑控制可以用 if - else 清楚地表达，那就不建议使用异常方式处理。异常捕捉是用来处理不期望发生的事情，而错误码则用来处理可能会发生的事。

* 对于同类的错误处理，用一样的模式。比如，对于null对象的错误，要么都用返回 null，加上条件检查的模式，要么都用抛 NullPointerException 的方式处理。不要混用，这样有助于代码规范。

* 尽可能在错误发生的地方处理错误。因为这样会让调用者变得更简单。

* 向上尽可能地返回原始的错误。如果一定要把错误返回到更高层去处理，那么，应该返回原始的错误，而不是重新发明一个错误。

* 处理错误时，总是要清理已分配的资源。这点非常关键，使用 RAII 技术，或是 try-catch-finally，或是 Go 的 defer 都可以容易地做到。

* 不推荐在循环体里处理错误。这里说的是 try-catch，绝大多数的情况你不需要这样做。最好把整个循环体外放在 try 语句块内，而在外面做 catch。

* 不要把大量的代码都放在一个 try 语句块内。一个 try 语句块内的语句应该是完成一个简单单一的事情。

* 为你的错误定义提供清楚的文档以及每种错误的代码示例。如果你是做 RESTful API 方面的，使用 Swagger 会帮你很容易搞定这个事。

* 对于异步的方式，推荐使用 Promise 模式处理错误。对于这一点，JavaScript 中有很好的实践。

* 对于分布式的系统，推荐使用 APM 相关的软件。尤其是使用 Zipkin 这样的服务调用跟踪的分析来关联错误。

