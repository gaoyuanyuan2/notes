# 极客学习 

* 基础课程，操作系统、计算机网络、编译原理等等，当然还有数据结构和算法。

* 通过在公司工作提高自己的技能，让自己可以更为独立和自由地生活。

* 提高代码的重用度，能自动化的就自动化，和需求人员谈需求，简化掉需求。

* 并不是社会不尊重程序员，只要你能帮上大忙，就一定会赢得别人的尊重。

## 安全

* 1.使用开源的框架必须实时关注其动态，特别是安全漏洞方面

* 2.任何公开的入口，都必须进行严格的安全检查

* 3.框架的选型十分重要，必须将安全考察进去


### 以这些公司为例，我们来看看这些攻击是怎样实现的。

1. 利用程序框架或库的已知漏洞。比如这次 Equifax 被攻击，就是通过 Apache Struts 的
已知漏洞。RSA 被攻击，也利用了 Adobe Flash 的已知漏洞。还有之前的“心脏流
血”也是使用了 OpenSSL 的漏洞……

2. 暴力破解密码。利用密码字典库或是已经泄露的密码来“撞库”。

3. 代码注入。通过程序员代码的安全性问题，如 SQL 注入、XSS 攻击、CSRF 攻击等取得
用户的权限。

4. 利用程序日志不小心泄露的信息。携程的信息泄露就是本不应该能被读取的日志没有权
限保护被读到了。

5. 社会工程学。RSA 被攻击，第一道防线是人——RSA 的员工。只有员工的安全意识增强
了，才能抵御此类攻击。其它的如钓鱼攻击也属于此类。

然后，除了表面的攻击之外，窃取到的信息也显示了一些数据管理上的问题。

1. 只有一层安全。Equifax 只是被黑客攻破了管理面板和数据库，就造成了数据泄露。显然
这样只有一层安全防护是不够的。

2. 弱密码。Equifax 数据泄露事件绝对是管理问题。至少，密码系统应该不能让用户设置如
此简单的密码，而且还要定期更换。最好的方式是通过数据证书、VPN、双因子验证的
方式来登录。

3. 向公网暴露了内部系统。在公司网络管理上出现了非常严重的问题。

4. 对系统及时打安全补丁。监控业内的安全漏洞事件，及时做出响应，这是任何一个有高
价值数据的公司都需要干的事。

5. 安全日志被暴露。安全日志往往包含大量信息，被暴露是非常危险的。携程的 CVV 泄露
就是从日志中被读到的。

6. 保存了不必要保存的用户数据。携程保存了用户的信用卡号、有效期、姓名和 CVV 码，
这些信息足以让人在网上盗刷信用卡。其实对于临时支付来说，这些信息完全可以不保
存在磁盘上，临时在内存中处理完毕立即销毁，是最安全的做法。即便是快捷支付，也
没有必要保存 CVV 码。安全日志也没有必要将所有信息都保存下来，比如可以只保存卡
号后四位，也同样可以用于处理程序故障。

7. 密码没有被合理地散列。以现代的安全观念来说，以明文方式保存密码是很不专业的做
法。进一步的是只保存密码的散列值（用安全散列算法），LinkedIn 就是这样做的。但
是，散列一则需要用目前公认安全的算法（比如 SHA-2 256），而已知被攻破的算法则
最好不要使用（如 MD5，能人为找到碰撞，对密码验证来说问题不大），二则要加一个
安全随机数作为盐（salt）。LinkedIn 的问题正在于没有加盐，导致密码可以通过预先
计算的彩虹表（rainbow table）反查出明文。这些密码明文可以用来做什么事，就不好
说了，撞库什么的都有可能了。对用户来说，最好是不同网站用不同密码。

### 5 条最佳实践。

1. 理解你的软件产品中使用了哪些支持性框架和库，它们的版本号分别是多少。时刻跟踪
影响这些产品和版本的最新安全性声明。

2. 建立一个流程，来快速地部署带有安全补丁的软件产品发布版，这样一旦需要因为安全
方面的原因而更新支持性框架或库，就可以快速地发布。最好能在几个小时或几天内完
成，而不是几周或几个月。我们发现，绝大多数被攻破的情况是因为几个月或几年都没
有更新有漏洞的软件组件而引起的。

3. 所有复杂的软件都有漏洞。不要基于“支持性软件产品没有安全性漏洞”这样的假设来
建立安全策略。

4. 建立多个安全层。在一个面向公网的表示层（比如 Apache Struts 框架）后面建立多级
有安全防护的层次，是一种良好的软件工程实践。就算表示层被攻破，也不会直接提供
出重要（或所有）后台信息资源的访问权。

5. 针对公网资源，建立对异常访问模式的监控机制。现在有很多侦测这些行为模式的开源
和商业化产品，一旦发现异常访问就能发出警报。作为一种良好的运维实践，我们建议
针对关键业务的网页服务应用一定要有这些监控机制。

### 技术上的安全做法

首先，我们需要把我们的关键数据定义出来，然后把这些关键数据隔离出来，隔离到一个安
全级别非常高的地方。所谓安全级别非常高的地方，即这个地方需要有各种如安全审计、安
全监控、安全访问的区域。

一般来说，在这个区域内，这些敏感数据只入不出。通过提供服务接口来让别的系统只能在
这个区域内操作这些数据，而不是把数据传出去，让别的系统在外部来操作这些数据。
举个例子，用户的手机号是敏感信息。如果有外部系统需要使用手机号，一般来说是想发个
短信，那么我们这个掌管手机号数据的系统就对外提供发短信的功能，而外部系统通过
UID 或是别的抽像字段来调用这个系统的发短信的 API。信用卡也一样，提供信用卡的扣
款 API 而不是把卡号返回给外部系统。

另外，如果业务必需返回用户的数据，一般来说，最终用户可能需要读取自己的数据，那
么，对于像信用卡这样的关键数据是死也不能返回全部数据的，只能返回一个被“马赛
克”了的数据（隐藏掉部分信息）。就算需要返回一些数据（如用户的地址），那么也需要
在传输层上加密返回。

而用户加密的算法一定要采用非对称加密的方式，而且还要加上密钥的自动化更换，比如：
在外部系统调用 100 次或是第一个小时后就自动更换加密的密钥。这样，整个系统在运行
时就完全是自动化的了，而就算黑客得到了密钥，密匙也会过期，这样可以控制泄露范围。
通过上述手段，我们可以把数据控制在一个比较小的区域内。

而在这个区域内，我们依然会有相关的内部员工可以访问，因此，这个区域中的数据也是需
要加密存放的，而加密使用的密钥则需要放在另外一个区域中。也就是说，被加密的数据和用于加密的密钥是由不同的人来管理的，有密钥的人没有数据，
有数据的人没有密钥，这两拨人可以有访问自己系统的权限，但是没有访问对方系统的权
限。这样可以让这两拨人互相审计，互相牵制，从而提高数据的安全性。比如，这两拨人是
不同公司的。

而密钥一定要做到随机生成，最好是对于不同用户的数据有不同的密钥，并且时不时地就能
自动化更新一下，这样就可以做到内部防范。注明一下，按道理来说，用户自己的私钥应该
由用户自己来保管，而公司的系统是不存的。而用户需要更新密钥时，需要对用户做身份鉴
别，可以通过双因子认证，也可以通过更为严格的物理身份验证。例如，到银行柜台拿身份
证重置密码。

最后，每当这些关键信息传到外部系统，需要做通知，最好是通知用户和自己的管理员。并
且限制外部系统的数据访问量，超过访问量后，需要报警或是拒绝访问。

## 何为技术领导力？

尊重技术的公司和不尊重技术的公司在初期可能还不能显现，而长期来看，差距就很明显了。

* 能够发现问题。能够发现现有方案的问题。
* 能够提供解决问题的思路和方案，并能比较这些方案的优缺点。
* 能够做出正确的技术决定。用什么样的技术、什么解决方案、怎样实现来完成一个项目。
* 能够用更优雅，更简单，更容易的方式来解决问题。
* 能够提高代码或软件的扩展性、重用性和可维护性。
* 能够用正确的方式管理团队。
  * 让正确的人做正确的事，并发挥每个人的潜力；
  * 可以提高团队的生产力和人效，找到最有价值的需求，用最少的成本实现之。并且，可以不断地提高自身和团队的标准。创新能力。
* 能够使用新的方法新的方式解决问题，追逐新的工具和技术。

##  如何才能拥有技术领导力？

* 第一，你要吃透基础技术。基础技术是各种上层技术共同的基础。

### 编程部分

* C 语言：相对于很多其他高级语言来说，C 语言更接近底层。在具备跨平台能力的前提下，它可以比较容易地被人工翻译成相应的汇编代码。它的内存管理更为直接，可以让我们直接和内存地址打交道。
* 编程范式：各种编程语言都有它们各自的编程范式，用于解决各种问题。比如面向对象编程（C++、Java）、泛型编程（C++、Go、C#）、函数式编程（JavaScript、 Python、Lisp、Haskell、Erlang）等。
* 算法和数据结构：算法（及其相应的数据结构）是程序设计的有力支撑。适当地应用算法，可以有效地抽象问题，提高程序的合理性和执行效率。算法是编程中最最重要的东西，也是计算机科学中最重要的基础。

### 系统部分

* 计算机系统原理：CPU 的体系结构（指令集 [CISC/RISC]、分支预测、缓存结构、 总线、DMA
、中断、陷阱、多任务、虚拟内存、虚拟化等），内存的原理与性能特点（SRAM、DRAM、DDR-SDRAM
 等），磁盘的原理（机械硬盘 [盘面、磁头臂、磁头、启停区、寻道等]、固态硬盘 [页映射、块的合并与回收算法、TRIM 指令等]），GPU 的原理等。
 
* 操作系统原理和基础：进程、进程管理、线程、线程调度、多核的缓存一致性、信号量、物理内存管理、虚拟内存管理、内存分配、文件系统、磁盘管理等。

* 网络基础：计算机网络是现代计算机不可或缺的一部分。需要了解基本的网络层次结构（ISO/OSI 模型、TCP/IP 协议栈），包括物理层、数据链路层（包含错误重发机制）、网络层（包含路由机制）、传输层（包含连接保持机制）、会话层、表示层、应用层（在 TCP/IP 协议栈里，这三层可以并为一层）。
 
* 数据库原理：数据库管理系统是管理数据库的利器。

* 分布式技术架构：数据库和应用程序服务器在应对互联网上数以亿计的访问量的时候，需要能进行横向扩展，这样才能提供足够高的性能。为了做到这一点，要学习分布式技术架构，包括负载均衡、DNS 解析、多子域名、无状态应用层、缓存层、数据库分片、容错和恢复机制、Paxos、Map/Reduce 操作、分布式 SQL 数据库一致性（以 Google Cloud Spanner 为代表）等知识点。

### 坚持做正确的事。做正确的事，比用正确的方式做事更重要，因为这样才始终会向目的地靠拢。哪些是正确的事呢？下面是我的观点：

* 提高效率的事。你要学习和掌握良好的时间管理方式，管理好自己的时间，能显著提高自己的效率。

* 自动化的事。程序员要充分利用自己的职业特质，当看见有可以自动化的步骤时，编写程序来自动化操作，可以显著提高效率。

* 掌握前沿技术的事。掌握前沿的技术，有利于拓展自己的眼界，也有利于找到更好的工作。需要注意的是，有些技术虽然当下很火，但未必前沿，而是因为它比较易学易用，或者性价比高。由于学习一门技术需要花费不少时间，你应该选择自己最感兴趣的，有的放矢地去学习。

* 知识密集型的事。知识密集型是相对于劳动密集型来说的。基本上，劳动密集型的事都能通过程序和机器来完成，而知识密集型的事却仍需要人来完成，所以人的价值此时就显现出来了。虽然现在人工智能似乎能做一些知识密集型的事（包括下围棋的 AlphaGo），但是在开放领域中相对于人的智能来说还是相去甚远。掌握了领域知识的人的价值依然很高。

* 技术驱动的事。不仅是指用程序驱动的事，而且还包括一切技术改变生活的事。比如自动驾驶、火星登陆等。就算自己一时用不着，你也要了解这些，以便将来这些技术来临时能适应它们。

## PaaS 层的技术主要能解决下面这些问题

* 软件生产线的问题。持续集成和持续发布，以及 DevOps 中的技术必须通过 PaaS。

* 分布式服务化的问题。分布式服务化的服务高可用、服务编排、服务调度、服务发现、服务路由，以及分布式服务化的支撑技术完全是 PaaS 的菜。

* 提高服务的可用性 SLA。提高服务可用性 SLA 所需要的分布式、高可用的技术架构和运维工具，也是 PaaS 层提供的。

* 软件能力的复用。软件工程中的核心就是软件能力的复用，这一点也完美地体现在 PaaS 平台的技术上。

Go 语言和 Docker 作为 PaaS 平台的关键技术前途是无限的

## 异常

### 你可能会觉得异常捕捉对程序的性能是有影响的，这句话也对也不对。原因是这样的。

* 异常捕捉的确是对性能有影响的，那是因为一旦异常被抛出，函数也就跟着 return 了。而程序在执行时需要处理函数栈的上下文，这会导致性能变得很慢，尤其是函数栈比较深的时候。

* 但从另一方面来说，异常的抛出基本上表明程序的错误。程序在绝大多数情况下，应该是在没有异常的情况下运行的，所以，有异常的情况应该是少数的情况，不会影响正常处理的性能问题。

### 错误返回码 vs 异常捕捉

* 对于我们并不期望会发生的事，我们可以使用异常捕捉；

* 对于我们觉得可能会发生的事，使用返回码。

### 异步编程

对此，在异步编程的世界里，我们也会有好几种处理错误的方法，最常用的就是 callback 方式。
在做异步请求的时候，注册几个 OnSuccess()、 OnFailure() 这样的函数，让在另一个线程中运行的异步代码来回调过来。

### 错误处理的最佳实践

* 统一分类的错误字典。无论你是使用错误码还是异常捕捉，都需要认真并统一地做好错误的分类。最好是在一个地方定义相关的错误。比如，HTTP 的 4XX 表示客户端有问题，5XX 则表示服务端有问题。也就是说，你要建立一个错误字典。

* 同类错误的定义最好是可以扩展的。这一点非常重要，而对于这一点，通过面向对象的继承或是像 Go 语言那样的接口多态可以很好地做到。这样可以方便地重用已有的代码。

* 定义错误的严重程度。比如，Fatal 表示重大错误，Error 表示资源或需求得不到满足，Warning 表示并不一定是个错误但还是需要引起注意，Info 表示不是错误只是一个信息，Debug 表示这是给内部开发人员用于调试程序的。

* 错误日志的输出最好使用错误码，而不是错误信息。打印错误日志的时候，应该使用统一的格式。但最好不要用错误信息，而应使用相应的错误码，错误码不一定是数字，也可以是一个能从错误字典里找到的一个唯一的可以让人读懂的关键字。这样，会非常有利于日志分析软件进行自动化监控，而不是要从错误信息中做语义分析。比如：HTTP 的日志中就会有 HTTP 的返回码，如：404。但我更推荐使用像PageNotFound这样的标识，这样人和机器都很容易处理。

* 忽略错误最好有日志。不然会给维护带来很大的麻烦。

* 对于同一个地方不停的报错，最好不要都打到日志里。不然这样会导致其它日志被淹没了，也会导致日志文件太大。最好的实践是，打出一个错误以及出现的次数。

* 不要用错误处理逻辑来处理业务逻辑。也就是说，不要使用异常捕捉这样的方式来处理业务逻辑，而是应该用条件判断。如果一个逻辑控制可以用 if - else 清楚地表达，那就不建议使用异常方式处理。异常捕捉是用来处理不期望发生的事情，而错误码则用来处理可能会发生的事。

* 对于同类的错误处理，用一样的模式。比如，对于null对象的错误，要么都用返回 null，加上条件检查的模式，要么都用抛 NullPointerException 的方式处理。不要混用，这样有助于代码规范。

* 尽可能在错误发生的地方处理错误。因为这样会让调用者变得更简单。

* 向上尽可能地返回原始的错误。如果一定要把错误返回到更高层去处理，那么，应该返回原始的错误，而不是重新发明一个错误。

* 处理错误时，总是要清理已分配的资源。这点非常关键，使用 RAII 技术，或是 try-catch-finally，或是 Go 的 defer 都可以容易地做到。

* 不推荐在循环体里处理错误。这里说的是 try-catch，绝大多数的情况你不需要这样做。最好把整个循环体外放在 try 语句块内，而在外面做 catch。

* 不要把大量的代码都放在一个 try 语句块内。一个 try 语句块内的语句应该是完成一个简单单一的事情。

* 为你的错误定义提供清楚的文档以及每种错误的代码示例。如果你是做 RESTful API 方面的，使用 Swagger 会帮你很容易搞定这个事。

* 对于异步的方式，推荐使用 Promise 模式处理错误。对于这一点，JavaScript 中有很好的实践。

* 对于分布式的系统，推荐使用 APM 相关的软件。尤其是使用 Zipkin 这样的服务调用跟踪的分析来关联错误。

## 故障处理最佳实践

### 故障源团队通常会有以下几种手段来恢复系统。

* 重启和限流。重启和限流主要解决的是可用性的问题，不是功能性的问题。重启还好说，但是限流这个事就需要相关的流控中间件了。

* 回滚操作。回滚操作一般来说是解决新代码的 bug，把代码回滚到之前的版本是快速的方式。

* 降级操作。并不是所有的代码变更都是能够回滚的，如果无法回滚，就需要降级功能了。也就是说，需要挂一个停止服务的故障公告，主要是不要把事态扩大。

* 紧急更新。紧急更新是常用的手段，这个需要强大的自动化系统，尤其是自动化测试和自动化发布系统。假如你要紧急更新 1000 多台服务器，没有一个强大的自动化发布系统是很难做到的。

### 故障前的准备工作

* 以用户功能为索引的服务和资源的全视图。首先，我们需要一个系统来记录前端用户操作界面和后端服务，以及服务使用到的硬件资源之间的关联关系。这个系统有点像 CMDB（配置管理数据库），但是比 CMDB 要大得多，是以用户端的功能来做索引的。然后，把后端的服务、服务的调用关系，以及服务使用到的资源都关联起来做成一个视图。

* 这个视图最好是由相应的自动化监控系统生成。有了这个资源图后，我们就可以很容易地找到处理故障的路径了。这就好像一张地图，如果没有地图，我们只能像个无头苍蝇一样乱试了。

* 为地图中的各个服务制定关键指标，以及一套运维流程和工具，包括应急方案。以用户功能为索引，为每个用户功能的服务都制定一个服务故障的检测、处理和恢复手册，以及相关的检测、查错或是恢复的运维工具。对于基础层和一些通用的中间件，也需要有相应的最佳实践的方法。

比如 Redis，怎样检查其是否存在问题，怎样查看其健康和运行状态？哪些是关键指标，面对常见的故障应该怎么应对，服务不可用的服务方案是什么，服务需要回滚了应该怎么操作，等等。这就好像一个导航仪，能够告诉你怎么做。而没有导航仪，就没有章法，会导致混乱。

* 设定故障的等级。还要设定不同故障等级的处理方式。比如，亚马逊一般将故障分为 4 级：1 级是全站不可用；2 级是某功能不可用，且无替代方案；3 级是某功能不可用，但有替代方案；4 级是非功能性故障，或是用户不关心的故障。阿里内的分类更多样一些，有时会根据影响多少用户来定故障等级。

* 制定故障等级，主要是为了确定该故障要牵扯进多大规模的人员来处理。故障级别越高，牵扯进来的人就越多，参与进来的管理层级别也就越高。就像亚马逊的全员上线 oncall 一样。这就好像是我们社会中常用的“红色警报”、“橙色警报”、“黄色警报”之类的，会触发不同的处理流程。

* 故障演练。故障是需要演练的。因为故障并不会时常发生，但我们又需要不断提升处理故障的能力，所以需要经常演练。一些大公司，如 Netflix，会有一个叫 Chaos Monkey 的东西，随机地在生产线上乱来。Facebook 也会有一些故障演习，比如，随机关掉线上的一些服务器。总之，要提升故障处理水平，最好的方式就是实践。见得多了，处理得多了，才能驾轻就熟。故障演练是一个非常好的实践。

* 灰度发布系统。要减少线上故障的影响范围，通过灰度发布系统来发布是一个很不错的方式。毕竟，我们在测试环境中很难模拟出线上环境的所有情况，所以，在生产线上进行灰度发布或是 A/B 测试是一件很好的事。

### 故障整改方法

* 第一，优化故障获知和故障定位的时间。

从故障发生到我们知道的时间是否可以优化得更短？
定位故障的时间是否可以更短？
有哪些地方可以做到自动化？

* 第二，优化故障的处理方式。

故障处理时的判断和章法是否科学，是否正确？
故障处理时的信息是否全透明？
故障处理时人员是否安排得当？

* 第三，优化开发过程中的问题。

Code Review 和测试中的问题和优化点。
软件架构和设计是否可以更好？
对于技术欠债或是相关的隐患问题是否被记录下来，是否有风险计划？

* 第四，优化团队能力。

如何提高团队的技术能力？
如何让团队有严谨的工程意识？

## 分布式系统架构

* 增大系统容量。
* 加强系统可用。

### 优势

* 因为模块化，所以系统模块重用度更高；

* 因为软件服务模块被拆分，开发和发布速度可以并行而变得更快；

* 系统扩展性更高；

* 团队协作流程也会得到改善；

### 比较了单体应用和分布式架构的优缺点

||传统单体架构| 分布式服务化架构|
|---|---|---|
|新功能开发|需要时间|容易开发和实现|
|部署|不经常且容易部署|经常发布，部署复杂|
|隔离性|故障影响范围大|故障影响范围小|
|架构设计|难度小|难度级数增加|
|系统性能|响应时间快，吞吐量小|响应时间慢，吞吐量大|
|系统运维|运维简单|运维复杂|
|新人上手|学习曲线大(应用逻辑)|学习曲线大(架构逻辑)|
|技术|技术单一且封闭|技术多样且开放|
|测试和查错|简单|复杂|
|系统扩展性|扩展性很差|扩展性很好|
|系统管理|重点在于开发成本|重点在于服务治理和调度|

### 存在一些问题。

* 架构设计变得复杂（尤其是其中的分布式事务）。

* 部署单个服务会比较快，但是如果一次部署需要多个服务，流程会变得复杂。

* 系统的吞吐量会变大，但是响应时间会变长。

* 运维复杂度会因为服务变多而变得很复杂。

* 架构复杂导致学习曲线变大。

* 测试和查错的复杂度增大。

* 技术多元化，这会带来维护和运维的复杂度。

* 管理分布式系统中的服务和调度变得困难和复杂。

微服务的出现使得开发速度变得更快，部署快，隔离性高，系统的扩展度也很好，但是在集成测试、运维和服务管理等方面就比较麻烦了。所以，需要一套比较好的微服务 PaaS 平台。就像 Spring Cloud 一样需要提供各种配置服务、服务发现、智能路由、控制总线……还有像 Kubernetes 提供的各式各样的部署和调度方式。

### 服务的依赖也会带来一些问题。

* 如果非关键业务被关键业务所依赖，会导致非关键业务变成一个关键业务。

* 服务依赖链中，出现“木桶短板效应”——整个 SLA 由最差的那个服务所决定。

### 系统分成四层：基础层、平台层、应用层和接入层。

* 基础层就是我们的机器、网络和存储设备等。

* 平台层就是我们的中间件层，Tomcat、MySQL、Redis、Kafka 之类的软件。

* 应用层就是我们的业务软件，比如，各种功能的服务。

* 接入层就是接入用户请求的网关、负载均衡或是 CDN、DNS 这样的东西。

### 分布式系统中需要注意的问题异

* 构系统的不标准问题
  * 软件和应用不标准。
  * 通讯协议不标准。
  * 数据格式不标准。
  * 开发和运维的过程和方法不标准。 
  
* 系统架构中的服务依赖性问题
  * 如果非关键业务被关键业务所依赖，会导致非关键业务变成一个关键业务。
  * 服务依赖链中，出现“木桶短板效应”——整个 SLA 由最差的那个服务所决定。

这里需要注意的是，很多分布式架构在应用层上做到了业务隔离，然而，在数据库结点上并没有。如果一个非关键业务把数据库拖死，那么会导致全站不可用。

* 故障发生的概率更大

防火胜于救火，在设计时就要考虑如何减轻故障。如果无法避免，也要使用自动化的方式恢复故障，减少故障影响面。人管代码，代码管机器，人不管机器！

* 多层架构的运维复杂度更大

很多公司都是按技能分工的，他们按照技能把技术团队分为产品开发、中间件开发、业务运维、系统运维等子团队。这样的分工导致的结果就是大家各管一摊，很多事情完全连不在一起。整个系统会像 “多米诺骨牌”一样，一个环节出现问题，就会倒下去一大片。因为没有一个统一的运维视图，不知道一个服务调用是如何经过每一个服务和资源，也就导致在出现故障时要花大量的时间在沟通和定位问题上。


### 构建分布式系统的目的是增加系统容量，提高系统的可用性，转换成技术方面，也就是完成下面两件事

* 大流量处理。

通过集群技术把大规模并发请求的负载分散到不同的机器上。

* 关键业务保护。

提高后台服务的可用性，把故障隔离起来阻止多米诺骨牌效应（雪崩效应）。如果流量过大，需要对业务降级，以保护关键业务流转。

### 提高架构的性能

![提高架构的性能](/img/2.png)

* 缓存系统。

加入缓存系统，可以有效地提高系统的访问能力。从前端的浏览器，到网络，再到后端的服务，底层的数据库、文件系统、硬盘和 CPU，全都有缓存，这是提高快速访问能力最有效的手段。对于分布式系统下的缓存系统，需要的是一个缓存集群。这其中需要一个 Proxy 来做缓存的分片和路由。

* 负载均衡系统。

负载均衡系统是水平扩展的关键技术，它可以使用多台机器来共同分担一部分流量请求。

* 异步调用。

异步系统主要通过消息队列来对请求做排队处理，这样可以把前端的请求的峰值给“削平”了，而后端通过自己能够处理的速度来处理请求。这样可以增加系统的吞吐量，但是实时性就差很多了。同时，还会引入消息丢失的问题，所以要对消息做持久化，这会造成“有状态”的结点，从而增加了服务调度的难度。

* 数据分区和数据镜像。

数据分区是把数据按一定的方式分成多个区（比如通过地理位置），不同的数据区来分担不同区的流量。这需要一个数据路由的中间件，会导致跨库的 Join 和跨库的事务非常复杂。而数据镜像是把一个数据库镜像成多份一样的数据，这样就不需要数据路由的中间件了。你可以在任意结点上进行读写，内部会自行同步数据。然而，数据镜像中最大的问题就是数据的一致性问题。

### 提高架构的稳定性

![提高架构的稳定性](/img/3.png)

* 服务拆分。

服务拆分主要有两个目的：一是为了隔离故障，二是为了重用服务模块。但服务拆分完之后，会引入服务调用间的依赖问题。

* 服务冗余。

服务冗余是为了去除单点故障，并可以支持服务的弹性伸缩，以及故障迁移。然而，对于一些有状态的服务来说，冗余这些有状态的服务带来了更高的复杂性。其中一个是弹性伸缩时，需要考虑数据的复制或是重新分片，迁移的时候还要迁移数据到其它机器上。

* 限流降级。

当系统实在扛不住压力时，只能通过限流或者功能降级的方式来停掉一部分服务，或是拒绝一部分用户，以确保整个架构不会挂掉。这些技术属于保护措施。

* 高可用架构。

通常来说高可用架构是从冗余架构的角度来保障可用性。比如，多租户隔离，灾备多活，或是数据可以在其中复制保持一致性的集群。总之，就是为了不出单点故障。

* 高可用运维。

高可用运维指的是 DevOps 中的 CI/CD（持续集成 / 持续部署）。一个良好的运维应该是一条很流畅的软件发布管线，其中做了足够的自动化测试，还可以做相应的灰度发布，以及对线上系统的自动化控制。这样，可以做到“计划内”或是“非计划内”的宕机事件的时长最短。+

### 分布式系统的关键技术

* 服务治理。

服务拆分、服务调用、服务发现、服务依赖、服务的关键度定义……服务治理的最大意义是需要把服务间的依赖关系、服务调用链，以及关键的服务给梳理出来，并对这些服务进行性能和可用性方面的管理。

* 架构软件管理。

服务之间有依赖，而且有兼容性问题，所以，整体服务所形成的架构需要有架构版本管理、整体架构的生命周期管理，以及对服务的编排、聚合、事务处理等服务调度功能。

* DevOps。

分布式系统可以更为快速地更新服务，但是对于服务的测试和部署都会是挑战。所以，还需要 DevOps 的全流程，其中包括环境构建、持续集成、持续部署等。

* 自动化运维。

有了 DevOps 后，我们就可以对服务进行自动伸缩、故障迁移、配置管理、状态管理等一系列的自动化运维技术了。

* 资源调度管理。

应用层的自动化运维需要基础层的调度支持，也就是云计算 IaaS 层的计算、存储、网络等资源调度、隔离和管理。

* 整体架构监控。

如果没有一个好的监控系统，那么自动化运维和资源调度管理只可能成为一个泡影，因为监控系统是你的眼睛。没有眼睛，没有数据，就无法进行高效的运维。所以说，监控是非常重要的部分。这里的监控需要对三层系统（应用层、中间件层、基础层）进行监控。

* 流量控制。

最后是我们的流量控制，负载均衡、服务路由、熔断、降级、限流等和流量相关的调度都会在这里，包括灰度发布之类的功能也在这里。

### 分布式系统有五个关键技术

* 全栈系统监控；
* 服务 / 资源调度；
* 流量调度；
* 状态 / 数据调度；
* 开发和运维的自动化。

![分布式系统有五个关键技术](/img/1.png)

### 多层体系的监控

![多层体系的监控](/img/4.png)

### 服务治理上的一些关键技术

* 服务关键程度
* 服务依赖关系
* 服务发现
* 整个架构的版本管理
* 服务应用生命周期全管理

### 服务关键程度和服务的依赖关系

* 微服务是服务依赖最优解的上限，而服务依赖的下限是千万不要有依赖环

### 流量调度的主要功能

* 依据系统运行的情况，自动地进行流量调度，在无需人工干预的情况下，提升整个系统的稳定性；
  
* 让系统应对爆品等突发事件时，在弹性计算扩缩容的较长时间窗口内或底层资源消耗殆尽的情况下，保护系统平稳运行。

### 流量调度系统还可以完成以下几方面的事情(所有的这些都应该是一个 API Gateway 应该做的事)

* 服务流控。服务发现、服务路由、服务降级、服务熔断、服务保护等。
* 流量控制。负载均衡、流量分配、流量控制、异地灾备（多活）等。
* 流量管理。协议转换、请求校验、数据缓存、数据计算等。

### 流量调度的关键技术

* 高性能。

API Gateway 必须使用高性能的技术，所以，也就需要使用高性能的语言。

* 扛流量。

要能扛流量，就需要使用集群技术。集群技术的关键点是在集群内的各个结点中共享数据。这就需要使用像 Paxos、Raft、Gossip 这样的通讯协议。因为 Gateway 需要部署在广域网上，所以还需要集群的分组技术。

* 业务逻辑。

API Gateway 需要有简单的业务逻辑，所以，最好是像 AWS 的 Lambda 服务一样，可以让人注入不同语言的简单业务逻辑。

* 服务化。

一个好的 API Gateway 需要能够通过 Admin API 来不停机地管理配置变更，而不是通过一个.conf 文件来人肉地修改配置。

### 在解决数据副本间的一致性问题时，我们有一些技术方案。

* Master-Slave 方案。
* Master-Master 方案。
* 两阶段和三阶段提交方案。
* Paxos 方案。

### PaaS 平台的本质

![PaaS](/img/5.png)

一个好的 PaaS 平台应该具有分布式、服务化、自动化部署、高可用、敏捷以及分层开放的特征，并可与 IaaS 实现良好的联动。

* PaaS 调度层 – 主要是 PaaS 的自动化和分布式对于高可用高性能的管理。
* PaaS 能力服务层 – 主要是 PaaS 真正提供给用户的服务和能力。
* PaaS 的流量调度 – 主要是与流量调度相关的东西，包括对高并发的管理。
* PaaS 的运营管理 – 软件资源库、软件接入、认证和开放平台门户。
* PaaS 的运维管理 – 主要是 DevOps 相关的东西。
